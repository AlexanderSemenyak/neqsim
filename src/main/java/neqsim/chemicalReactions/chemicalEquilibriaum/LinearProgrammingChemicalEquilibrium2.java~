/*
 * LinearProgrammingChemicalEquilibrium.java
 *
 * Created on 11. april 2001, 10:04
 */

package chemicalReactions.chemicalEquilibrium;


import thermo.system.*;
import MathLib.JamaLinAlg.*;
import thermo.component.*;
import java.util.*;
import chemicalReactions.*;
/**
 *
 * @author  Even Solbraa
 * @version
 */
public class LinearProgrammingChemicalEquilibrium2 extends Object implements thermo.ThermodynamicConstantsInterface{
    
    double[] xEts = null;
    double[][] Amatrix;
    double[] chemRefPot;
    ComponentInterface[] components;
    double[] numbering;
    String[] elements;
    int changes=0, minChanges=0, maxChanges=0;
    ChemicalReactionOperations operations;
    /** Creates new LinearProgrammingChemicalEquilibrium */
    public LinearProgrammingChemicalEquilibrium2(){
    }
    
    public LinearProgrammingChemicalEquilibrium2(double[] chemRefPot, ComponentInterface[] components, String[] elements, ChemicalReactionOperations operations) {
        this.operations = operations;
        this.chemRefPot = chemRefPot;
        this.components = components;
        this.elements = elements;
        this.Amatrix = Amatrix;
        changes = elements.length;
        minChanges = elements.length;
        maxChanges = components.length;
        System.out.println("max: " + maxChanges + " MIN: " +minChanges);
        for(int i=0;i<components.length;i++) {
            components[i].setReferencePotential(chemRefPot[i]);
            System.out.println("sorting....." +chemRefPot[i]);
        }
        Arrays.sort(components,new ReferencePotComparator());
        //    this.changePrimaryComponents();
        if(operations.calcChemRefPot()!=null){
            System.arraycopy(operations.calcChemRefPot(),0,this.chemRefPot,0,this.chemRefPot.length);
            for(int i=0;i<components.length;i++) {
                components[i].setReferencePotential(chemRefPot[i]);
                System.out.println("sorting....." + components[i].getComponentNumber());
            }
            for(int i=0;i<components.length;i++) {
                chemRefPot[i] = components[i].getReferencePotential();
                System.out.println("sorting....." +chemRefPot[i]);
            }
        }
        else{
            do{
                System.out.println("shifting components....." );
                this.changePrimaryComponents();
            }
            while(operations.calcChemRefPot()==null);
            System.out.println("shifting components....." );
            System.arraycopy(operations.calcChemRefPot(),0,this.chemRefPot,0,this.chemRefPot.length);
            for(int i=0;i<components.length;i++) {
                components[i].setReferencePotential(chemRefPot[i]);
                System.out.println("sorting....." +chemRefPot[i]);
            }
            Arrays.sort(components,new ReferencePotComparator());
            for(int i=0;i<components.length;i++) {
                chemRefPot[i] = components[i].getReferencePotential();
                System.out.println("sorting....." +chemRefPot[i]);
            }
        }
        
        this.Amatrix = calcA();
        new Matrix(Amatrix).print(10,3);
    }
    
    public double[][] calcA(){
        double[][] A = new double[elements.length+1][components.length];
        
        for(int k=0;k<elements.length;k++) {
            for(int i=0; i<components.length;i++){
                for(int j=0;j<components[i].getElements().getElementNames().length;j++){
                    if(components[i].getElements().getElementNames()[j].equals(elements[k])){
                        A[k][i] = components[i].getElements().getElementCoefs()[j];
                    }
                }
            }
        }
        for(int i=0; i<components.length;i++){
            A[elements.length][i] = components[i].getIonicCharge();
        }
        Amatrix = A;
        return A;
    }
    
    public double[][] getA(){
        return Amatrix;
    }
    
    public double[] getRefPot(){
        return chemRefPot;
    }
    
    public void changePrimaryComponents(){
        if(changes==maxChanges && minChanges>=0){
            changes=minChanges;
            minChanges--;
        }
        ComponentInterface tempComp;
        tempComp = (ComponentInterface) components[minChanges-1].clone();
        components[minChanges-1] = (ComponentInterface) components[changes].clone();
        components[changes] = tempComp;
        changes++;
        //  chemRefPot = operations.calcChemRefPot();
        /*
        this.Amatrix = calcA();
        Matrix temp = ((Matrix) (new Matrix(Amatrix))).getMatrix(0, elements.length-1, 0, elements.length-1);
        System.out.println("rank....." +temp.rank());*/
    }
    
    public double[] generateInitialEstimates(SystemInterface system,  double[] bVector, double inertMoles){
        Matrix solved;
        Matrix atemp = new Matrix(Amatrix).getMatrix(0,Amatrix.length-2,0,Amatrix[0].length-1);
        Matrix mutemp = new Matrix(chemRefPot,1).times(1.0/(R*system.getTemperature()));
        Matrix lagrangeTemp = atemp.transpose().solve(mutemp.transpose());
        
        System.out.println("lagranges: ");
        lagrangeTemp.print(10,2);
        System.out.println("refpot: ");
        mutemp.print(10,2);
        
        
        
        Matrix rTemp = new Matrix(atemp.getRowDimension(),1);
        rTemp.set(0,0,inertMoles/bVector[0]);
        for(int i=1;i<atemp.getRowDimension();i++){
            rTemp.set(i,0, bVector[i]/bVector[0]);
        }
        
        System.out.println("rMatTemp: ");
        rTemp.print(10,5);
        
        
        
        Matrix zTemp = new Matrix(atemp.getRowDimension(),1);
        for(int i=0;i<atemp.getRowDimension();i++){
            zTemp.set(i,0, Math.exp(lagrangeTemp.get(i,0)));
        }
        
        System.out.println("rMatTemp: ");
        zTemp.print(10,5);
        
                
        Matrix phiMatTemp = new Matrix(atemp.getRowDimension(),1); //atemp.transpose().solve(mutemp.transpose());
        for(int i=0;i<atemp.getRowDimension();i++) {
            phiMatTemp.set(i,0,zTemp.get(i,0));
        }
        for(int i=1;i<atemp.getRowDimension();i++){
            phiMatTemp.set(0,0,phiMatTemp.get(0,0)*Math.pow(phiMatTemp.get(i,0),rTemp.get(i,0)));
        }
    //    System.out.println("phiMatTemp: ");
    //    phiMatTemp.print(10,10);
        
        
        
        Matrix betaTemp = atemp.copy();
        for(int j=0;j<atemp.getColumnDimension();j++){
            betaTemp.set(0,j,1.0 + rTemp.get(0,0)*atemp.get(0,j));
        }
        
        for(int i=1;i<atemp.getRowDimension();i++) {
            for(int j=0;j<atemp.getColumnDimension();j++){
                betaTemp.set(i,j,atemp.get(i,j)-rTemp.get(i,0)*atemp.get(0,j));
            }
        }
        
 //       System.out.println("betaTemp: ");
  //      betaTemp.print(10,10);
        
        
        Matrix alphaTemp = betaTemp.copy();
        for(int j=0;j<Amatrix[0].length;j++){
            alphaTemp.set(0,j,atemp.get(0,j));
        }
    //    System.out.println("alphaTemp: ");
    //    alphaTemp.print(10,10);
        
        
        do{
        double[] fVal = new double[atemp.getRowDimension()];
        double[][] dfVal = new double[atemp.getRowDimension()][atemp.getRowDimension()];
        
        //creates f-vlas
        
            
            for(int i=0;i<atemp.getRowDimension();i++) {
                fVal[i]=0;
                for(int j=0;j<atemp.getColumnDimension();j++){
                    double phiTemp = 1.0;
                    for(int k=0;k<atemp.getRowDimension();k++) {
                        phiTemp = phiTemp*Math.pow(phiMatTemp.get(k,0),alphaTemp.get(k,j));
                    }
                    fVal[i] += betaTemp.get(i,j)*Math.exp(-chemRefPot[j]/(R*system.getTemperature()))*phiTemp;
                }
                //    System.out.println("fval: " +  fVal[i]);
            }
            fVal[0] = fVal[0] - 1.0;
            
            for(int i=0;i<atemp.getRowDimension();i++){
                for(int j=0;j<atemp.getRowDimension();j++) {
                    for(int k=0;k<atemp.getColumnDimension();k++){
                        double phiTemp = 1.0;
                        for(int p=0;p<atemp.getRowDimension();p++) {
                            phiTemp = phiTemp*Math.pow(phiMatTemp.get(p,0),alphaTemp.get(p,k));
                        }
                        dfVal[i][j] += betaTemp.get(i,k)*alphaTemp.get(j,k)*Math.exp(-chemRefPot[k]/(R*system.getTemperature()))*phiTemp;
                    }
                }
            }
            
            
            //  System.out.println("solved: ");
            Matrix fMatrix = new Matrix(fVal,1);
            Matrix dfMatrix = new Matrix(dfVal);
            solved = dfMatrix.solve(fMatrix.timesEquals(-1.0).transpose());
            
             fMatrix.print(10,2);
            //  dfMatrix.print(10,2);
              System.out.println("solved: ");
              solved.print(10,6);
            
            for(int i=0;i<atemp.getRowDimension();i++) {
                phiMatTemp.set(i,0,Math.exp(solved.get(i,0))*phiMatTemp.get(i,0));
            }
            //  System.out.println("phiMatTemp: ");
            //  phiMatTemp.print(10,10);
        }
        while(Math.abs(solved.norm2())>1e-10);
        
            double temp=1.0;
            for(int i=1;i<atemp.getRowDimension();i++) {
                zTemp.set(i,0, phiMatTemp.get(i,0));
                temp = temp*Math.pow(zTemp.get(i,0),rTemp.get(i,0));
            }
            zTemp.set(0,0,phiMatTemp.get(0,0)/temp);
         
        xEts = new double[atemp.getColumnDimension()];
        double sum=0;
        for(int k=0;k<atemp.getColumnDimension();k++){
            xEts[k] = Math.exp(-chemRefPot[k]/(R*system.getTemperature()));
            for(int i=0;i<atemp.getRowDimension();i++) {
                xEts[k] = xEts[k]*Math.pow(zTemp.get(i,0),atemp.get(i,k));
            }
            sum += xEts[k];
            System.out.println("x check: " + xEts[k]);
        }
               
        double[] nEts = new double[atemp.getColumnDimension()];
        for(int k=0;k<atemp.getColumnDimension();k++){
            nEts[k] = xEts[k]*system.getPhases()[1].getNumberOfMolesInPhase();
            System.out.println("N check: " + nEts[k]);
        }
        
        return nEts;
    }
    
    public void calcx(Matrix atemp, Matrix lagrangeTemp){
    /*     xEts = new double[atemp.getColumnDimension()];
        for(int k=0;k<atemp.getColumnDimension();k++){
            xEts[k] = Math.exp(-chemRefPot[k]/(R*system.getTemperature()));
            for(int i=0;i<Amatrix.length;i++) {
                xEts[k] = xEts[k]*Math.pow(Math.exp(lagrangeTemp.get(i,0)),atemp.get(i,k));
            }
            System.out.println("x check: " + xEts[k]);
          /*  if(xEts[k]>200) {
                this.changePrimaryComponents();
                return this.generateInitialEstimates(system, bVector, inertMoles);
            }
        }
        xEts = new double[Amatrix[0].length];
        for(int i=0;i<Amatrix.length;i++) {
            xEts[i] = 1.0;
        }*/
    }
}
