/*
 * ChemicalReactionOperations.java
 *
 * Created on 4. februar 2001, 20:06
 */

package chemicalReactions;

import thermo.system.*;
import thermo.phase.*;
import thermo.component.*;
import chemicalReactions.chemicalReaction.*;
import java.util.*;
import java.io.*;
import MathLib.JamaLinAlg.*;
import chemicalReactions.chemicalEquilibriaum.*;
import chemicalReactions.kinetics.*;
/**
 *
 * @author  Even Solbraa
 * @version
 */
public class ChemicalReactionOperations extends Object implements thermo.ThermodynamicConstantsInterface,Cloneable {
    
    SystemInterface system;
    ComponentInterface[] components;
    ChemicalReactionList reactionList = new ChemicalReactionList();
    String[] componentNames;
    String[] allComponentNames;
    String[] elements;
    double[][] Amatrix;
    double[] nVector;
    int iter = 0;
    double[] bVector;
    int phase = 1;
    double[] chemRefPot;
    double[] newMoles;
    double[] referencePotentials;
    double inertMoles=0.0;
    ChemicalEquilibrium solver;
    double deltaReactionHeat=0.0;
    boolean firsttime=true;
    Kinetics kineticsSolver;
    LinearProgrammingChemicalEquilibrium initCalc;
    /** Creates new ChemicalReactionOperations */
    public ChemicalReactionOperations() {
    }
    
    public ChemicalReactionOperations(SystemInterface system) {
        initCalc = new LinearProgrammingChemicalEquilibrium();
        boolean newcomps= true;
        int old=system.getPhase(0).getNumberOfComponents();
        
        this.system = system;
        componentNames = system.getComponentNames();
        reactionList.readReactions();
        reactionList.removeJunkReactions(componentNames);
        allComponentNames = reactionList.getAllComponents();
        if(allComponentNames.length==old) newcomps=false;
        old = allComponentNames.length;
        this.addNewComponents();
        
        //  for(int p=0;p<15;p++){
        int numeroftimes=0;
        do{
            numeroftimes++;
            this.system = system;
            componentNames = system.getComponentNames();
            reactionList.readReactions();
            reactionList.removeJunkReactions(componentNames);
            allComponentNames = reactionList.getAllComponents();
            if(allComponentNames.length==old) newcomps=false;
            old = allComponentNames.length;
            this.addNewComponents();
        }
        while(newcomps || numeroftimes<15);
        
        components = new ComponentInterface[allComponentNames.length];
        if(components.length>0){
            setReactiveComponents();
            reactionList.checkReactions(system.getPhase(1),components);
            chemRefPot = calcChemRefPot(1);
            elements = this.getAllElements();
            initCalc = new LinearProgrammingChemicalEquilibrium(chemRefPot, components, elements, this, 1);
            setComponents();
            Amatrix = initCalc.getA();
            nVector = calcNVector();
            bVector = calcBVector();
        }
        else{
            system.isChemicalSystem(false);
        }
        kineticsSolver = new Kinetics(this);
    }
    
    public void setSystem(SystemInterface system){
        this.system = system;
    }
    
    public Object clone(){
        ChemicalReactionOperations clonedSystem = null;
        try{
            clonedSystem = (ChemicalReactionOperations) super.clone();
        }
        catch(Exception e) {
            e.printStackTrace(System.err);
        }
        return clonedSystem;
    }
    
    public void setComponents(){
        for(int j=0;j<components.length;j++){
            system.getPhases()[1].getComponents()[components[j].getComponentNumber()] = components[j];
        }
    }
    
    public void setComponents(int phase){
        for(int j=0;j<components.length;j++){
            system.getPhases()[phase].getComponents()[components[j].getComponentNumber()] = components[j];
        }
    }
    
    public void setReactiveComponents(int phase){
        for(int j=0;j<components.length;j++){
            components[j] = system.getPhases()[phase].getComponents()[components[j].getComponentNumber()];
        }
    }
    
    public void setReactiveComponents(){
        int k=0;
        for(int j=0;j<componentNames.length;j++) {
            String name = componentNames[j];
            for(int i=0; i<allComponentNames.length;i++) {
                if(name.equals(allComponentNames[i])){
                    components[k++] = system.getPhases()[1].getComponents()[j];
                }
            }
        }
    }
    
    public double calcInertMoles(int phase){
        double reactiveMoles =0;
        for(int j=0;j<components.length;j++){
            reactiveMoles += components[j].getNumberOfMolesInPhase();
        }
        inertMoles = system.getPhases()[phase].getNumberOfMolesInPhase()-reactiveMoles;
        //System.out.println("inertmoles = " + inertMoles);
        if(inertMoles<0) inertMoles=1e-10;
        return inertMoles;
    }
    
    public void sortReactiveComponents(){
        ComponentInterface tempComp;
        for(int i=0;i<components.length;i++){
            for(int j=i+1;j<components.length;j++){
                if(components[j].getGibbsEnergyOfFormation()<components[i].getGibbsEnergyOfFormation()){
                    tempComp = components[i];
                    components[i] = components[j];
                    components[j] = tempComp;
                    //                    System.out.println("swich : " + i + " " + j);
                }
            }
        }
    }
    
    public void addNewComponents(){
        boolean newComp;
        int p=0;
        
        for(int i=0; i<allComponentNames.length;i++) {
            String name = allComponentNames[i];
            newComp = true;
            
            for(int j=0;j<componentNames.length;j++) {
                if(name.equals(componentNames[j])){
                    newComp = false;
                    break;
                }
            }
            if(newComp){
                system.addComponent(name,system.getNumberOfMoles()/1.0e6,1);
                System.out.println("new component added: " + name);
            }
        }
    }
    
    public String[] getAllElements(){
        HashSet elements = new HashSet();
        for(int j=0;j<components.length;j++){
            for(int i=0; i<components[j].getElements().getElementNames().length;i++){
                elements.add(components[j].getElements().getElementNames()[i]);
            }
        }
        
        String[] elementList = new String[elements.size()];
        int k=0;
        Iterator newe = elements.iterator();
        while(newe.hasNext()){
            elementList[k++] = (String) newe.next();
        }
        return elementList;
    }
    
    
    public boolean hasRections(){
        if(components.length>0) return true;
        else return false;
    }
    
    public double[] calcNVector(){
        double[] nvec = new double[components.length];
        for(int i=0;i<components.length;i++){
            nvec[i] = components[i].getNumberOfMolesInPhase();
            //   System.out.println("nvec: " + nvec[i]);
        }
        return nvec;
    }
    
    public double[] calcBVector(){
        Matrix tempA = new Matrix(Amatrix);
        Matrix tempB = new Matrix(nVector,1);
        Matrix tempN = tempA.times(tempB.transpose()).transpose();
        //        System.out.println("b matrix: ");
        //        tempN.print(10,2);
        
        return tempN.getArray()[0];
    }
    
    public double[] calcChemRefPot(int phase){
        double[] referencePotentials = new double[components.length];
        reactionList.createReactionMatrix(system.getPhase(phase),components);
        double[] newreferencePotentials = reactionList.calcReferencePotentials(system.getPhase(phase), components);
        if(newreferencePotentials!=null){
            for(int i=0;i<newreferencePotentials.length;i++) {
                referencePotentials[i] = newreferencePotentials[i];
                components[i].setReferencePotential(referencePotentials[i]);
            }
            return referencePotentials;
        }
        else {
            return null;
        }
    }
    
    public void updateMoles(int phase){
        double changeMoles=0.0;
        for(int i=0;i<components.length;i++){
            changeMoles += (newMoles[i]-system.getPhases()[phase].getComponents()[components[i].getComponentNumber()].getNumberOfMolesInPhase());
            system.getPhase(phase).addMolesChemReac(components[i].getComponentNumber(),(newMoles[i]-system.getPhases()[phase].getComponents()[components[i].getComponentNumber()].getNumberOfMolesInPhase()));
        }
        //System.out.println("change " + changeMoles);
        system.initTotalNumberOfMoles(changeMoles);//x_solve.get(NELE,0)*n_t);
        system.initBeta(); // this was added for mass trans calc
        system.init_x_y();
        system.init(1);
    }
    
    public boolean solveChemEq(int type){
        return solveChemEq(1, type);
    }
    
    public boolean solveChemEq(int phase, int type){
        if(this.phase != phase) setReactiveComponents(phase);
        this.phase = phase;
        if(!system.isChemicalSystem()){
            System.out.println("no chemical reactions will occur...continue");
            return false;
        }
        calcChemRefPot(phase);
        
        if(firsttime==true && type==110){
            try{
                //System.out.println("initial estimate");
                nVector = calcNVector();
                bVector = calcBVector();
                calcInertMoles(phase);
                newMoles = initCalc.generateInitialEstimates(system, bVector, inertMoles, phase);
                updateMoles(phase);
                firsttime=false;
                return true;
            }
            catch(Exception e){
                //System.out.println("error in chem eq");
                solver = new ChemicalEquilibrium(Amatrix, bVector, system, components, phase);
                return solver.solve();
            }
        }
        else{
             nVector = calcNVector();
            bVector = calcBVector();
            try{
                solver = new ChemicalEquilibrium(Amatrix, bVector, system, components, phase);
            }
            catch(Exception e){
                e.printStackTrace();
            }
            return solver.solve();
        }
    }
    
    
    public double solveKinetics(int phase, PhaseInterface interPhase, int component){
        return kineticsSolver.calcReacMatrix(system.getPhase(phase), interPhase, component);
    }
    
    public Kinetics getKinetics(){
        return kineticsSolver;
    }
    
    public ChemicalReactionList getReactionList(){
        return reactionList;
    }
    
    public double reacHeat(int phase, String component){
        return reactionList.reacHeat(system.getPhase(phase), component);
    }
    
    
    /** Getter for property deltaReactionHeat.
     * @return Value of property deltaReactionHeat.
     */
    public double getDeltaReactionHeat() {
        return deltaReactionHeat;
    }
    
    /** Setter for property deltaReactionHeat.
     * @param deltaReactionHeat New value of property deltaReactionHeat.
     */
    public void setDeltaReactionHeat(double deltaReactionHeat) {
        this.deltaReactionHeat = deltaReactionHeat;
    }
    
    //    public Matrix calcReacRates(int phase){
    //        //        System.out.println(" vol " + system.getPhases()[0].getMolarVolume());
    //        return getReactionList().calcReacRates(system.getPhase(phase), components);
    //    }
    //
    //    /** Setter for property reactionList.
    //     * @param reactionList New value of property reactionList.
    //     */
    //    public void setReactionList(chemicalReactions.chemicalReaction.ChemicalReactionList reactionList) {
    //        this.reactionList = reactionList;
    //    }
    
}
