/*
 * PhaseEos.java
 *
 * Created on 3. juni 2000, 14:38
 */

package thermo.phase;

import thermo.component.*;
import thermo.mixingRule.*;
import MathLib.nonLinearSolver.*;
/**
 *
 * @author  Even Solbraa
 * @version
 */
abstract class PhaseEos extends Phase implements PhaseEosInterface{
    
    public double A, AT, ATT, B, molarVolume=1.0, delta1 = 0, delta2 = 0, f=0, g=0;
    public static double Zold=0;
    boolean mixingRuleDefined = false;
    public EosMixingRules mixSelect = new EosMixingRules();
    public EosMixingRulesInterface mixRule;
    int uEOS=0,wEOS=0;
    newtonRhapson solver;
    
    // Class methods
    
    public Object clone(){
        PhaseEos clonedPhase = null;
        try{
            clonedPhase = (PhaseEos) super.clone();
        }
        catch(Exception e) {
            e.printStackTrace(System.err);
        }
        
        //        clonedPhase.mixSelect = (EosMixingRules2) clonedPhase.mixSelect.clone();
        //        clonedPhase.mixRule = (EosMixingRulesInterface) clonedPhase.mixRule.clone();
        
        return clonedPhase;
    }
    
    
    /** Creates new PhaseEos */
    public PhaseEos() {
        super();
        componentArray = new ComponentEosInterface[10];
        mixRule = mixSelect.getMixingRule(1);
        //solver = new  newtonRhapson();
    }
    
    public EosMixingRulesInterface getMixingRule(){
        return mixRule;
    }
    
    public void addcomponent(double moles){
        super.addcomponent(moles);
    }
    
    public void init(double totalNumberOfMoles, int numberOfComponents, int type, int phase, double beta){ // type = 0 start init type =1 gi nye betingelser
        super.init(totalNumberOfMoles, numberOfComponents, type, phase, beta);
        if(!mixingRuleDefined){
            setMixingRule(1);
            System.out.println("mixing rule: default no. 1");
        }
        A = calcA(this, temperature, pressure, numberOfComponents );
        B = calcB(this, temperature, pressure, numberOfComponents );
        if(type!=0){
            try{
                molarVolume = molarVolume(pressure, temperature, getA()/numberOfMolesInPhase/numberOfMolesInPhase, getB()/numberOfMolesInPhase, phase);
            }
            catch(Exception e){
                System.err.println("too many iterations in volume calc!");
                System.err.println("A " + A);
                System.err.println("B " + B);
                System.err.println("moles " + numberOfMolesInPhase);
                System.err.println("molarVolume " + molarVolume);
                //System.exit(0);
            }
            
            for (int i=0; i < numberOfComponents; i++){
                componentArray[i].Finit(this, temperature, pressure, totalNumberOfMoles, beta, numberOfComponents, type);
            }
            
            f = calcf();
            g = calcg();
            
            if(type>=2){
                AT = calcAT(this, temperature, pressure,numberOfComponents );
                ATT = calcATT(this, temperature, pressure,numberOfComponents );
            }
        }
        return;
    }
    
    public void setMixingRule(int type){
        mixingRuleDefined = true;
        super.setMixingRule(type);
        mixRule = mixSelect.getMixingRule(type, this);
    }
    
    public void resetMixingRule(int type){
        mixingRuleDefined = true;
        super.setMixingRule(type);
        mixRule = mixSelect.resetMixingRule(type, this);
    }
    
    
    public double molarVolume2(double pressure, double temperature, double A, double B, int phase)  throws util.exception.IsNaNException, util.exception.TooManyIterationsException{
        
        double BonV = phase== 0 ? 2.0/(2.0+temperature/getPseudoCriticalTemperature()):pressure*getB()/(numberOfMolesInPhase*temperature*R);
        if(BonV<0) BonV = 0.0;
        if(BonV>1.0) BonV = 1.0;
        double BonVold=BonV;
        double Btemp=0, Dtemp=0, h=0, dh=0, gvvv=0, fvvv=0, dhh=0;
        double d1=0, d2=0;
        Btemp = getB();
        Dtemp = getA();
        
        molarVolume = 1.0/BonV*Btemp/numberOfMolesInPhase;
        int iterations = 0;
        
        do{
            iterations++;
            BonVold = BonV;
            h = BonV + Btemp*gV() + Btemp*Dtemp/(numberOfMolesInPhase*temperature)*fv()-pressure*Btemp/(numberOfMolesInPhase*R*temperature);
            dh = 1.0-Btemp/(BonV*BonV)*(Btemp*gVV()+Btemp*Dtemp*fVV()/(numberOfMolesInPhase*temperature));
            fvvv = 1.0/(R*Btemp*(delta1-delta2))*(2.0/Math.pow(numberOfMolesInPhase*molarVolume+Btemp*delta1,3.0) - 2.0/Math.pow(numberOfMolesInPhase*molarVolume+Btemp*delta2,3.0));
            gvvv = 2.0/Math.pow(numberOfMolesInPhase*molarVolume-Btemp,3.0)-2.0/Math.pow(numberOfMolesInPhase*molarVolume,3.0);
            dhh = 2.0*Btemp/Math.pow(BonV,3.0)*(Btemp*gVV()+Btemp*Dtemp/(numberOfMolesInPhase*temperature)*fVV()) + Btemp*Btemp/Math.pow(BonV,4.0)*(Btemp*gvvv + Btemp*Dtemp/(numberOfMolesInPhase*temperature)*fvvv) ;
            
            d1 = - h/dh;
            d2 = - dh/dhh;
            
            if(Math.abs(d1/d2)<=1.0){
                BonV += d1*(1.0+0.5*d1/d2);
            }
            else if(d1/d2<-1){
                BonV += d1*(1.0+0.5*-1.0);
            }
            else if(d1/d2>1){
                BonV += d2;
                double hnew = h +d2*dh;
                if(Math.abs(hnew)>Math.abs(h)) BonV += 0;
            }
            
            if(BonV>1){
                BonV=1.0-1.0e-16;
                BonVold=10;
            }
            if(BonV<0){
                BonV=1.0e-16;
                BonVold=10;
            }
            
            molarVolume = 1.0/BonV*Btemp/numberOfMolesInPhase;
            Z = pressure*molarVolume/(R*temperature);
        }
        while(Math.abs(BonV-BonVold)>1.0e-9 && iterations<1000);
        // molarVolume = 1.0/BonV*Btemp/numberOfMolesInPhase;
        // Z = pressure*molarVolume/(R*temperature);
        // System.out.println("BonV: " + BonV + " " + h + " " +dh + " B " + Btemp + "  D " + Dtemp + " gv" + gV() + " fv " + fv() + " fvv" + fVV());
        //  System.out.println("BonV: " + BonV + " "+"  itert: " +   iterations +" " +h + " " +dh + " B " + Btemp + "  D " + Dtemp + " gv" + gV() + " fv " + fv() + " fvv" + fVV());
        if(iterations>=1000) throw new util.exception.TooManyIterationsException();
        if(Double.isNaN(molarVolume)) throw new util.exception.IsNaNException();
        // System.out.println("BonV: " + BonV + " "+"  itert: " +   iterations +" " +h + " " +dh + " B " + Btemp + "  D " + Dtemp + " gv" + gV() + " fv " + fv() + " fvv" + fVV());
        
        return molarVolume;
    }
    
    public double molarVolume(double pressure, double temperature, double A, double B, int phase) throws util.exception.IsNaNException, util.exception.TooManyIterationsException{
        
        double BonV = phase == 0 ? 2.0/(2.0+temperature/getPseudoCriticalTemperature()):pressure*getB()/(numberOfMolesInPhase*temperature*R);
        
        if(BonV<0) BonV = 1.0e-4;
        if(BonV>1.0) BonV = 1.0-1.0e-4;
        double BonVold=BonV;
        double Btemp=0, Dtemp=0, h=0, dh=0, gvvv=0, fvvv=0, dhh=0;
        double d1=0, d2=0;
        Btemp = getB();
        Dtemp = getA();
        if(Btemp<0){System.out.println("b negative in volume calc");}
        molarVolume = 1.0/BonV*Btemp/numberOfMolesInPhase;
        int iterations = 0;
        
        do{
            iterations++;
            BonVold = BonV;
            h = BonV - Btemp/numberOfMolesInPhase*dFdV()-pressure*Btemp/(numberOfMolesInPhase*R*temperature);
            dh = 1.0 + Btemp/Math.pow(BonV,2.0)*(Btemp/numberOfMolesInPhase*dFdVdV());
            dhh = -2.0*Btemp/Math.pow(BonV,3.0)*(Btemp/numberOfMolesInPhase*dFdVdV())-Math.pow(Btemp,2.0)/Math.pow(BonV,4.0)*(Btemp/numberOfMolesInPhase*dFdVdVdV());
            
            d1 = - h/dh;
            d2 = - dh/dhh;
            
            if(Math.abs(d1/d2)<=1.0){
                BonV += d1*(1.0+0.5*d1/d2);
            }
            else if(d1/d2<-1){
                BonV += d1*(1.0+0.5*-1.0);
            }
            else if(d1/d2>1){
                BonV += d2;
                double hnew = h +d2*-h/d1;
                if(Math.abs(hnew)>Math.abs(h)){
                    BonV = phase== 1 ? 2.0/(2.0+temperature/getPseudoCriticalTemperature()):pressure*getB()/(numberOfMolesInPhase*temperature*R);
                }
            }
            
            if(BonV>1){
                BonV=1.0-1.0e-4;
                BonVold=10;
            }
            if(BonV<0){
                BonV=1.0e-4;
                BonVold=10;
            }
            
            molarVolume = 1.0/BonV*Btemp/numberOfMolesInPhase;
            Z = pressure*molarVolume/(R*temperature);
        }
        while(Math.abs((BonV-BonVold)/BonV)>1.0e-10 && iterations<1000);
        
        if(iterations>=100000) throw new util.exception.TooManyIterationsException();
        if(Double.isNaN(molarVolume)) throw new util.exception.IsNaNException();
        
        //System.out.println("BonV: " + BonV + " "+"  itert: " +   iterations +" " +h + " " +dh + " B " + Btemp + "  D " + Dtemp + " gv" + gV() + " fv " + fv() + " fvv" + fVV());
        
        return molarVolume;
    }
    
    
    public double getMolarVolume(){
        return molarVolume;
    }
    
    
    public double calcA(PhaseInterface phase, double temperature, double pressure, int numbcomp){
        A = mixRule.calcA(phase, temperature, pressure, numbcomp);
        return A;
    }
    public double calcB(PhaseInterface phase, double temperature, double pressure, int numbcomp){
        B =  mixRule.calcB(phase,  temperature,  pressure,  numbcomp);
        return B;
    }
    
    public double calcAi(int compNumb, PhaseInterface phase, double temperature, double pressure, int numbcomp){
        return mixRule.calcAi(compNumb, phase, temperature, pressure, numbcomp);
    }
    
    public double calcAT(PhaseInterface phase, double temperature, double pressure, int numbcomp){
        AT = mixRule.calcAT(phase, temperature, pressure, numbcomp);
        return AT;
    }
    
    public double calcATT(PhaseInterface phase, double temperature, double pressure, int numbcomp){
        ATT = mixRule.calcATT(phase, temperature, pressure, numbcomp);
        return ATT;
    }
    
    public double calcAiT(int compNumb, PhaseInterface phase, double temperature, double pressure, int numbcomp){
        return mixRule.calcAiT(compNumb, phase, temperature, pressure, numbcomp);
    }
    
    public double calcAij(int compNumb, int j, PhaseInterface phase, double temperature, double pressure, int numbcomp){
        return mixRule.calcAij(compNumb, j, phase, temperature, pressure, numbcomp);
    }
    
    public double calcBij(int compNumb, int j, PhaseInterface phase, double temperature, double pressure, int numbcomp){
        return mixRule.calcBij(compNumb, j, phase, temperature, pressure, numbcomp);
    }
    
    
    public double calcBi(int compNumb, PhaseInterface phase, double temperature, double pressure, int numbcomp){
        return mixRule.calcBi(compNumb, phase,  temperature,  pressure,  numbcomp);
    }
    
    
    public double geta(PhaseInterface phase, double temperature, double pressure, int numbcomp){
        return calcA(phase, temperature, pressure, numbcomp)/numberOfMolesInPhase/numberOfMolesInPhase;
    }
    
    public double getb(PhaseInterface phase, double temperature, double pressure, int numbcomp){
        return calcB(phase, temperature, pressure, numbcomp)/numberOfMolesInPhase;
    }
    
    public double geta(){
        return A/numberOfMolesInPhase/numberOfMolesInPhase;
    }
    
    public double getb(){
        return B/numberOfMolesInPhase;
    }
    
    public double getA(){
        return A;
    }
    
    public double getB(){
        return B;
    }
    
    public double getAT(){
        return AT;
    }
    
    public double getATT(){
        return ATT;
    }
    
    
    
    public double getAresTV(){
        return getF()*R*temperature;
    }
    
    public double getGresTP(){
        return getAresTV() + pressure * numberOfMolesInPhase * molarVolume - numberOfMolesInPhase * R * temperature*(1+Math.log(Z));
    }
    
    public double getSresTV(){
        return (-temperature*dFdT()-getF())*R;
    }
    
    public double getSresTP(){
        return getSresTV() +  numberOfMolesInPhase * R * Math.log(Z);
    }
    
    public double getHresTP(){
        return getAresTV() +  temperature * getSresTV() + pressure * numberOfMolesInPhase * molarVolume - numberOfMolesInPhase * R * temperature;
    }
    
    public double getCvres(){
        return (-temperature * temperature * dFdTdT() - 2.0* temperature * dFdT())*R;
    }
    
    public double getCpres(){
        return getCvres() + R*(-temperature/R*Math.pow(getdPdTVn(),2.0)/getdPdVTn() - numberOfMolesInPhase);
    }
    
    public double getJouleThomsonCoefficient(){
        return -1.0/getCp()*(getMolarVolume()*numberOfMolesInPhase+temperature*getdPdTVn()/getdPdVTn());
    }
    
    public double getdPdTVn(){
        return - R*temperature*dFdTdV()+pressure/temperature;
    }
    
    public double getdPdVTn(){
        return - R*temperature*dFdVdV() - numberOfMolesInPhase *R*temperature/Math.pow(numberOfMolesInPhase * molarVolume,2.0);
    }
    
    public double getdPdrho(){
        return getdPdVTn()*getdVdrho()*1e5;
    }
    
    public double getdVdrho(){
        return -1.0*numberOfMolesInPhase*this.getMolarMass()/Math.pow(this.getDensity(),2.0);
    }
    
    
    
    public double getg(){
        return g;
    }
    
    public double getf(){
        return f;
    }
    
    public double calcg(){
        return Math.log(1.0-getb()/molarVolume);
    }
    
    public double calcf(){
        return (1.0/(R*B*(delta1-delta2))*Math.log((1.0+delta1*getb()/molarVolume)/
        (1+delta2*getb()/(molarVolume))));
    }
    
    public double getF(){
        return -numberOfMolesInPhase *getg()-getA()/temperature*getf();
    }
    
    
    
    
    public double Fn() {
        return -getg();
    }
    
    public double FT() {
        return getA()*getf()/temperature/temperature;
    }
    
    public double FV() {
        return -numberOfMolesInPhase*gV() - getA()/temperature*fv();
    }
    
    public double FD() {
        return -getf()/temperature;
    }
    
    public double FB() {
        return -numberOfMolesInPhase*gb()- getA()/temperature*fb();
    }
    
    
    
    public double gb(){
        return -1.0/(numberOfMolesInPhase*getMolarVolume()-getB());
    }
    
    public double fb(){
        return -(getf()+numberOfMolesInPhase*getMolarVolume()*fv())/getB();
    }
    
    public double gV(){
        return getb()/(getMolarVolume()*(numberOfMolesInPhase*getMolarVolume()-getB()));
        //1/(numberOfMolesInPhase*getMolarVolume()-getB())-1/(numberOfMolesInPhase*getMolarVolume());
    }
    
    public double fv(){
        return -1.0/(R*(numberOfMolesInPhase*getMolarVolume()+delta1*getB())*(numberOfMolesInPhase*getMolarVolume()+delta2*getB()));
    }
    
    ////// NYE metoder fredag 25.08.public double dFdN(PhaseInterface phase, int numberOfComponents, double temperature, double pressure, int phasetype){
    
    public double FnV(){
        return 	-gV();
    }
    
    public double FnB(){
        return 	-gb();
    }
    
    public double FTT(){
        return 	-2.0/temperature*FT();
    }
    
    public double FBT(){
        return 	getA()*fb()/temperature/temperature;
    }
    
    public double FDT(){
        return 	getf()/temperature/temperature;
    }
    
    
    public double FBV(){
        return 	-numberOfMolesInPhase*gBV() -getA()*fBV()/temperature;
    }
    
    public double FBB(){
        return 	- numberOfMolesInPhase*gBB() -getA()*fBB()/temperature;
    }
    
    public double FDV(){
        return 	- fv()/temperature;
    }
    
    public double FBD(){
        return 	- fb()/temperature;
    }
    
    public double FTV(){
        return 	getA()*fv()/temperature/temperature;
    }
    
    public double FVV(){
        return 	- numberOfMolesInPhase*gVV() - getA()*fVV()/temperature;
    }
    
    public double FVVV(){
        return 	- numberOfMolesInPhase*gVVV() - getA()*fVVV()/temperature;
    }
    
    public double gVV(){
        return 	- 1.0/Math.pow(numberOfMolesInPhase*getMolarVolume()-getB(),2.0)+1.0/Math.pow(numberOfMolesInPhase*getMolarVolume(),2.0);
    }
    
    public double gVVV(){
        return 	2.0/Math.pow(numberOfMolesInPhase*getMolarVolume()-getB(),3.0)-2.0/Math.pow(numberOfMolesInPhase*getMolarVolume(),3.0);
    }
    
    public double gBV(){
        return 	 1.0/Math.pow(numberOfMolesInPhase*getMolarVolume()-getB(),2.0);
    }
    
    public double gBB(){
        return 	- 1.0/Math.pow(numberOfMolesInPhase*getMolarVolume()-getB(),2.0);
    }
    
    public double fVV(){
        return 	 1.0/(R*getB()*(delta1-delta2))*(-1.0/Math.pow((numberOfMolesInPhase*getMolarVolume()+delta1*getB()),2.0)+1.0/Math.pow((numberOfMolesInPhase*getMolarVolume()+delta2*getB()),2.0));
    }
    
    public double fVVV(){
        return 	1.0/(R*getB()*(delta1-delta2))*(2.0/Math.pow(numberOfMolesInPhase*getMolarVolume()+getB()*delta1,3.0) - 2.0/Math.pow(numberOfMolesInPhase*getMolarVolume()+getB()*delta2,3.0));
    }
    
    public double fBV(){
        return 	 -(2.0*fv()+numberOfMolesInPhase*getMolarVolume()*fVV())/getB();
    }
    
    public double fBB(){
        return 	 -(2.0*fb()+numberOfMolesInPhase*getMolarVolume()*fBV())/getB();
    }
    
    public double dFdT(){
        return 	FT()+FD()*getAT();
    }
    
    public double dFdV(){
        return 	FV();
    }
    
    
    public double dFdTdV(){
        return 	FTV()+FDV()*getAT();
    }
    
    
    public double dFdVdV(){
        return 	FVV();
    }
    
    public double dFdVdVdV(){
        return 	FVVV();
    }
    
    public double dFdTdT(){
        return 	FTT()
        +   2.0*FDT()*getAT()
        +   FD()*getATT();
    }
    
    public void method_0() {}
    
}