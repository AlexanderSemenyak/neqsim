/*
 * Element.java
 *
 * Created on 4. februar 2001, 22:11
 */

package thermo.atomElement;

import java.util.*;
import thermo.*;
import thermo.component.*;
import thermo.phase.*;
import java.io.*;
/**
 *
 * @author  Even Solbraa
 * @version
 */
public class UNIFACgroup extends Object implements ThermodynamicConstantsInterface, Comparable{
    
    double R=0.0;
    double Q=0.0;
    int n=0;
    double xComp=0.0, xMix=0.0;
    double QComp=0.0, QMix=0.0;
    double lnGammaComp=0.0, lnGammaMix=0.0;
    int groupIndex=0;
    String groupName = "";
    int mainGroup = 0;
    int subGroup = 0;
    /** Creates new Element */
    public UNIFACgroup() {
    }
    
    public UNIFACgroup(int groupNumber, int temp) {
        
        StringTokenizer tokenizer;
        String token;
        
        try{
            util.database.NeqSimDataBase database = new util.database.NeqSimDataBase();
            java.sql.ResultSet dataSet = null;
            try{
                dataSet =  database.getResultSet(("SELECT * FROM UNIFACGroupParam WHERE Secondary="+groupNumber + ""));
                dataSet.next();
                dataSet.getClob("name");
            }
            catch(Exception e){
                dataSet.close();
                dataSet =  database.getResultSet(("SELECT * FROM UNIFACGroupParam WHERE Secondary="+groupNumber + ""));
                dataSet.next();
            }
            n = temp;
            R = Double.parseDouble(dataSet.getString("VolumeR")) ;
            Q = Double.parseDouble(dataSet.getString("SurfAreaQ")) ;
            mainGroup = Integer.parseInt(dataSet.getString("Main")) ;
            subGroup = Integer.parseInt(dataSet.getString("Secondary")) ;
            groupName = dataSet.getString("Name");
            dataSet.close();
            database.getConnection().close();
        }
        
        catch (Exception e) {
            String err = e.toString();
            System.out.println(err);
        }
    }
    
    /** Getter for property R.
     * @return Value of property R.
     *
     */
    public double getR() {
        return R;
    }
    
    
    
    /** Setter for property R.
     * @param R New value of property R.
     *
     */
    public void setR(double R) {
        this.R = R;
    }
    
    /** Getter for property Q.
     * @return Value of property Q.
     *
     */
    public double getQ() {
        return Q;
    }
    
    /** Setter for property Q.
     * @param Q New value of property Q.
     *
     */
    public void setQ(double Q) {
        this.Q = Q;
    }
    
    /** Getter for property n.
     * @return Value of property n.
     *
     */
    public int getN() {
        return n;
    }
    
    /** Setter for property n.
     * @param n New value of property n.
     *
     */
    public void setN(int n) {
        this.n = n;
    }
    
    /** Getter for property mainGroup.
     * @return Value of property mainGroup.
     *
     */
    public int getMainGroup() {
        return mainGroup;
    }
    
    /** Setter for property mainGroup.
     * @param mainGroup New value of property mainGroup.
     *
     */
    public void setMainGroup(int mainGroup) {
        this.mainGroup = mainGroup;
    }
    
    /** Getter for property subGroup.
     * @return Value of property subGroup.
     *
     */
    public int getSubGroup() {
        return subGroup;
    }
    
    /** Setter for property subGroup.
     * @param subGroup New value of property subGroup.
     *
     */
    public void setSubGroup(int subGroup) {
        this.subGroup = subGroup;
    }
    
    /** Getter for property groupName.
     * @return Value of property groupName.
     *
     */
    public java.lang.String getGroupName() {
        return groupName;
    }
    
    /** Setter for property groupName.
     * @param groupName New value of property groupName.
     *
     */
    public void setGroupName(java.lang.String groupName) {
        this.groupName = groupName;
    }
    
    /** Compares this object with the specified object for order.  Returns a
     * negative integer, zero, or a positive integer as this object is less
     * than, equal to, or greater than the specified object.<p>
     *
     * In the foregoing description, the notation
     * <tt>sgn(</tt><i>expression</i><tt>)</tt> designates the mathematical
     * <i>signum</i> function, which is defined to return one of <tt>-1</tt>,
     * <tt>0</tt>, or <tt>1</tt> according to whether the value of <i>expression</i>
     * is negative, zero or positive.
     *
     * The implementor must ensure <tt>sgn(x.compareTo(y)) ==
     * -sgn(y.compareTo(x))</tt> for all <tt>x</tt> and <tt>y</tt>.  (This
     * implies that <tt>x.compareTo(y)</tt> must throw an exception iff
     * <tt>y.compareTo(x)</tt> throws an exception.)<p>
     *
     * The implementor must also ensure that the relation is transitive:
     * <tt>(x.compareTo(y)&gt;0 &amp;&amp; y.compareTo(z)&gt;0)</tt> implies
     * <tt>x.compareTo(z)&gt;0</tt>.<p>
     *
     * Finally, the implementer must ensure that <tt>x.compareTo(y)==0</tt>
     * implies that <tt>sgn(x.compareTo(z)) == sgn(y.compareTo(z))</tt>, for
     * all <tt>z</tt>.<p>
     *
     * It is strongly recommended, but <i>not</i> strictly required that
     * <tt>(x.compareTo(y)==0) == (x.equals(y))</tt>.  Generally speaking, any
     * class that implements the <tt>Comparable</tt> interface and violates
     * this condition should clearly indicate this fact.  The recommended
     * language is "Note: this class has a natural ordering that is
     * inconsistent with equals."
     *
     * @param   o the Object to be compared.
     * @return  a negative integer, zero, or a positive integer as this object
     * 		is less than, equal to, or greater than the specified object.
     *
     * @throws ClassCastException if the specified object's type prevents it
     *         from being compared to this Object.
     *
     */
    public boolean equals(Object o) {
        if(((UNIFACgroup)o).getSubGroup()==getSubGroup()) return true;
        else return false;
    }
    
    public int compareTo(java.lang.Object o){
        if(((UNIFACgroup)o).getSubGroup()<getSubGroup()) return 1;
        else if(((UNIFACgroup)o).getSubGroup()==getSubGroup()) return 0;
        else return -1;
    }
    
    /** Getter for property xComp.
     * @return Value of property xComp.
     *
     */
    
    public double calcXComp(ComponentGEUnifac component){
        double temp=0.0;
        for(int i=0;i<component.getNumberOfUNIFACgroups();i++){
            temp+= component.getUnifacGroup(i).getN();
        }
        xComp = getN()/temp;
        System.out.println("xcomp " + xComp);
        return xComp;
    }
    
    public double calcXMix(PhaseGEUnifac phase){
        double temp=0.0, temp2=0.0;
        for(int j=0;j<phase.getNumberOfComponents();j++){
            for(int i=0;i<((ComponentGEUnifac)phase.getComponent(j)).getNumberOfUNIFACgroups();i++){
                temp+= phase.getComponent(j).getx()*((ComponentGEUnifac)phase.getComponent(j)).getUnifacGroup(i).getN();
            }
        }
        for(int j=0;j<phase.getNumberOfComponents();j++){
            for(int i=0;i<((ComponentGEUnifac)phase.getComponent(j)).getNumberOfUNIFACgroups();i++){
                if(((ComponentGEUnifac)phase.getComponent(j)).getUnifacGroup(i).getSubGroup()==subGroup) temp2+= phase.getComponent(j).getx()*((ComponentGEUnifac)phase.getComponent(j)).getUnifacGroup(i).getN();
            }
        }
        xMix = temp2/temp;
          System.out.println("xMix " + xMix);
      
        return xMix;
    }
    
    public double calcQComp(ComponentGEUnifac component){
        double temp=0.0;
        for(int i=0;i<component.getNumberOfUNIFACgroups();i++){
            temp+= component.getUnifacGroup(i).getXComp()*component.getUnifacGroup(i).getQ();
        }
        QComp = getQ()*getXComp()/temp;
       // System.out.println("qcomp " + xComp);
        return QComp;
    }
    
    public double calcQMix(PhaseGEUnifac phase){
        double temp=0.0, temp2=0.0;
        for(int j=0;j<phase.getNumberOfComponents();j++){
            for(int i=0;i<((ComponentGEUnifac)phase.getComponent(j)).getNumberOfUNIFACgroups();i++){
                temp+= phase.getComponent(j).getx()*((ComponentGEUnifac)phase.getComponent(j)).getUnifacGroup(i).getXMix()*((ComponentGEUnifac)phase.getComponent(j)).getUnifacGroup(i).getQ();
            }
        }
        for(int j=0;j<phase.getNumberOfComponents();j++){
            for(int i=0;i<((ComponentGEUnifac)phase.getComponent(j)).getNumberOfUNIFACgroups();i++){
                if(((ComponentGEUnifac)phase.getComponent(j)).getUnifacGroup(i).getSubGroup()==subGroup) temp2+= phase.getComponent(j).getx()*((ComponentGEUnifac)phase.getComponent(j)).getUnifacGroup(i).getXMix()*((ComponentGEUnifac)phase.getComponent(j)).getUnifacGroup(i).getQ();
            }
        }
        //System.out.println("xmix " + xMix);
        QMix=temp2/temp;
        return QMix;
    }
    
    public double getXComp() {
        return xComp;
    }
    
    /** Setter for property xComp.
     * @param xComp New value of property xComp.
     *
     */
    public void setXComp(double xComp) {
        this.xComp = xComp;
    }
    
    
    
    
    /** Getter for property xMix.
     * @return Value of property xMix.
     *
     */
    public double getXMix() {
        return xMix;
    }
    
    /** Setter for property xMix.
     * @param xMix New value of property xMix.
     *
     */
    public void setXMix(double xMix) {
        this.xMix = xMix;
    }
    
    /** Getter for property QComp.
     * @return Value of property QComp.
     *
     */
    public double getQComp() {
        return QComp;
    }
    
    /** Setter for property QComp.
     * @param QComp New value of property QComp.
     *
     */
    public void setQComp(double QComp) {
        this.QComp = QComp;
    }
    
    /** Getter for property QMix.
     * @return Value of property QMix.
     *
     */
    public double getQMix() {
        return QMix;
    }
    
    /** Setter for property QMix.
     * @param QMix New value of property QMix.
     *
     */
    public void setQMix(double QMix) {
        this.QMix = QMix;
    }
    
    
    /** Getter for property groupIndex.
     * @return Value of property groupIndex.
     *
     */
    public int getGroupIndex() {
        return groupIndex;
    }
    
    /** Setter for property groupIndex.
     * @param groupIndex New value of property groupIndex.
     *
     */
    public void setGroupIndex(int groupIndex) {
        this.groupIndex = groupIndex;
    }
    
    /** Getter for property lnGammaComp.
     * @return Value of property lnGammaComp.
     *
     */
    public double getLnGammaComp() {
        return lnGammaComp;
    }
    
    /** Setter for property lnGammaComp.
     * @param lnGammaComp New value of property lnGammaComp.
     *
     */
    public void setLnGammaComp(double lnGammaComp) {
        this.lnGammaComp = lnGammaComp;
    }
    
    /** Getter for property lnGammaMix.
     * @return Value of property lnGammaMix.
     *
     */
    public double getLnGammaMix() {
        return lnGammaMix;
    }
    
    /** Setter for property lnGammaMix.
     * @param lnGammaMix New value of property lnGammaMix.
     *
     */
    public void setLnGammaMix(double lnGammaMix) {
        this.lnGammaMix = lnGammaMix;
    }
    
}
