/*
 * Flash.java
 *
 * Created on 2. oktober 2000, 22:22
 */

package thermodynamicOperations.flashOps;

import thermodynamicOperations.*;
import thermo.system.*;
import thermo.phase.*;
import javax.swing.*;
import javax.swing.event.*;
import MathLib.JamaLinAlg.*;
import java.awt.*;
import java.io.*;
import java.text.*;

/**
 *
 * @author  Even Solbraa
 * @version
 */
abstract class Flash extends BaseOperation implements OperationInterface, java.io.Serializable{
    
    SystemInterface system;
    int i=0, j=0, nummer=0, iterations=0,maxNumberOfIterations=1000;
    double gibbsEnergy=0, gibbsEnergyOld=0;
    double Kold=0, deviation=0, g0 = 0, g1=0;
    double lnOldOldOldK[], lnOldOldK[], lnK[];
    double lnOldK[];
    double oldoldDeltalnK[], oldDeltalnK[], deltalnK[];
    double tm[] = {1,1,1,1,1,1,1,1,1,1};
    int lowestGibbsEnergyPhase=0; // lowestGibbsEnergyPhase
    sysNewtonRhapsonTPflash secondOrderSolver;
    SystemInterface minimumGibbsEnergySystem;
    protected boolean solidCheck=false, stabilityCheck = false;
    /** Creates new Flash */
    
    public Flash() {
    }
    
    public int findLowestGibbsEnergyPhase(){
        minimumGibbsEnergySystem = (SystemInterface) system.clone();
        minimumGibbsEnergySystem.init(0);
        minimumGibbsEnergySystem.setNumberOfPhases(2);
        minimumGibbsEnergySystem.setPhaseType(0,1);
        minimumGibbsEnergySystem.setPhaseType(1,0);
        minimumGibbsEnergySystem.init(1);
        
        if(minimumGibbsEnergySystem.getPhases()[0].getGibbsEnergy() < minimumGibbsEnergySystem.getPhases()[1].getGibbsEnergy()){
            lowestGibbsEnergyPhase = 0;
        }
        else{
            lowestGibbsEnergyPhase= 1;
        }
        return lowestGibbsEnergyPhase;
    }
    
    public void stabilityAnalysis()  throws util.exception.IsNaNException, util.exception.TooManyIterationsException{
        double[] logWi = new double[system.getPhases()[0].getNumberOfComponents()];
        double[][] Wi = new double[2][system.getPhases()[0].getNumberOfComponents()];
        double[] sumw = new double[2];
        double sumz = 0, err=0;
        double[] oldlogw = new double[system.getPhases()[0].getNumberOfComponents()];
        double[] d = new double[system.getPhases()[0].getNumberOfComponents()];
        double[][] x = new double[2][system.getPhases()[0].getNumberOfComponents()];
        
        SystemInterface clonedSystem;//, minimumGibbsEnergySystem;
        clonedSystem = (SystemInterface) system.clone();
        clonedSystem.init(0);
        clonedSystem.setNumberOfPhases(2);
//        clonedSystem.setPhaseType(0,1);
//        clonedSystem.setPhaseType(1,0);
        clonedSystem.init(1);
        //        minimumGibbsEnergySystem.setNumberOfPhases(2);
        //        minimumGibbsEnergySystem.setPhaseType(0,1);
        //        minimumGibbsEnergySystem.setPhaseType(1,0);
        //        minimumGibbsEnergySystem.init(0);
        //        minimumGibbsEnergySystem.init(1);
        if(minimumGibbsEnergySystem.getPhases()[0].getGibbsEnergy() < minimumGibbsEnergySystem.getPhases()[1].getGibbsEnergy()){
            lowestGibbsEnergyPhase = 0;
        }
        else{
            lowestGibbsEnergyPhase=1;
        }
        System.out.println("low gibbs phase " + lowestGibbsEnergyPhase + " " +minimumGibbsEnergySystem.getPhases()[0].getGibbsEnergy() +"  " + minimumGibbsEnergySystem.getPhases()[1].getGibbsEnergy());
        sumz =0;
        sumw[1] =0;
        sumw[0] =0;
        for (int i=0;i<clonedSystem.getPhases()[0].getNumberOfComponents();i++){
            clonedSystem.getPhases()[0].getComponents()[i].setx(clonedSystem.getPhases()[0].getComponents()[i].getK()* clonedSystem.getPhases()[0].getComponents()[i].getz());
            clonedSystem.getPhases()[1].getComponents()[i].setx(1.0/ clonedSystem.getPhases()[0].getComponents()[i].getK()* clonedSystem.getPhases()[0].getComponents()[i].getz());
            
            sumw[1] += clonedSystem.getPhases()[1].getComponents()[i].getx();
            sumw[0] += clonedSystem.getPhases()[0].getComponents()[i].getx();
            sumz    += clonedSystem.getPhases()[0].getComponents()[i].getz();
        }
        
        for (int i=0;i<clonedSystem.getPhases()[0].getNumberOfComponents();i++){
            clonedSystem.getPhases()[1].getComponents()[i].setx( clonedSystem.getPhases()[1].getComponents()[i].getx()/sumw[1]);
            clonedSystem.getPhases()[0].getComponents()[i].setx( clonedSystem.getPhases()[0].getComponents()[i].getx()/sumw[0]);
            d[i] = Math.log(minimumGibbsEnergySystem.getPhases()[lowestGibbsEnergyPhase].getComponents()[i].getz())+ Math.log(minimumGibbsEnergySystem.getPhases()[lowestGibbsEnergyPhase].getComponents()[i].getFugasityCoeffisient());
            
            // System.out.println("di: " + d[i]);
        }
        
        
        for (int j=0;j<clonedSystem.getNumberOfPhases();j++){
            logWi[0] =1;
            logWi[1] =1;
            int iterations=0;
            do{
                iterations++;
                err = 0;
                
                if (iterations<1000){
                    // succsessive substitution
                    clonedSystem.init(1);
                    for (int i=0;i<clonedSystem.getPhases()[0].getNumberOfComponents();i++){
                        oldlogw[i] =    logWi[i];
                        logWi[i] = d[i]- Math.log(clonedSystem.getPhases()[j].getComponents()[i].getFugasityCoeffisient());
                        err += Math.abs((logWi[i]-oldlogw[i])/oldlogw[i]);
                        Wi[j][i] = Math.exp(logWi[i]);
                    }
                    sumw[j] = 0;
                    for (int i=0;i<clonedSystem.getPhases()[0].getNumberOfComponents();i++){
                        sumw[j] = sumw[j] + Wi[j][i];
                    }
                }
                else{
                    // second order method
                    // this does not yet correctly work
                    //                    clonedSystem.init(3);
                    //                    double[] alpha = new double[system.getPhases()[0].getNumberOfComponents()];
                    //                    Matrix f = new Matrix(system.getPhases()[0].getNumberOfComponents(), 1);
                    //                    Matrix df = new Matrix(system.getPhases()[0].getNumberOfComponents(), system.getPhases()[0].getNumberOfComponents());
                    //
                    //                    for (int i=0;i<clonedSystem.getPhases()[0].getNumberOfComponents();i++){
                    //                        alpha[i] = 2*Math.sqrt(Wi[j][i]);
                    //                    }
                    //
                    //                    for (int i=0;i<clonedSystem.getPhases()[0].getNumberOfComponents();i++){
                    //                        f.set(i,0, Math.sqrt(Wi[j][i])*(Math.log(Wi[j][i] + Math.log(clonedSystem.getPhases()[j].getComponents()[i].getFugasityCoeffisient()))-d[i]));
                    //                        for (int k=0;k<clonedSystem.getPhases()[0].getNumberOfComponents();k++){
                    //                            double kronDelt = (i==j) ? 1.0:0.0;
                    //                            df.set(i,j, kronDelt * (1.0 + f.get(i,0)/alpha[i] + Math.sqrt(Wi[j][i]/sumw[j]*Wi[j][k]/sumw[j]*clonedSystem.getPhases()[j].getComponents()[i].getdfugdn(k))));
                    //                        }
                    //                    }
                    //                    f.print(10,10);
                    //                    df.print(10,10);
                    //                    Matrix dx = df.solve(f);
                    //                    dx.print(10,10);
                }
                for (int i=0;i<clonedSystem.getPhases()[0].getNumberOfComponents();i++){
                    clonedSystem.getPhases()[j].getComponents()[i].setx(Wi[j][i]/sumw[j]);
                }
            }
            while((err>1e-10 && iterations<1000) || iterations<10000);
            System.out.println("err " + err);
            if(iterations>=100000){
                System.out.println("err " + err);
                throw new util.exception.TooManyIterationsException();
            }
            
            tm[j] = 1.0;
            for (int i=0;i<clonedSystem.getPhases()[0].getNumberOfComponents();i++){
                tm[j] = tm[j] - Wi[j][i];
                x[j][i] = clonedSystem.getPhases()[j].getComponents()[i].getx();
            }
        }
        if((tm[0]<-1e-7 || tm[1]<-1e-7) && !(Double.isNaN(tm[0]) || (Double.isNaN(tm[1])))){
            for (int i=0;i<clonedSystem.getPhases()[0].getNumberOfComponents();i++){
                if(tm[0]<-1e-7) {
                    system.getPhases()[1].getComponents()[i].setK((Wi[0][i]/sumw[0])/(Wi[1][i]/sumw[1]));
                    system.getPhases()[0].getComponents()[i].setK((Wi[0][i]/sumw[0])/(Wi[1][i]/sumw[1]));
                }
                
                else if(tm[1]<-1e-7){
                    system.getPhases()[1].getComponents()[i].setK((Wi[0][i]/sumw[0])/(Wi[1][i]/sumw[1]));
                    system.getPhases()[0].getComponents()[i].setK((Wi[0][i]/sumw[0])/(Wi[1][i]/sumw[1]));
                }
                else system.init(0);
                
                if(Double.isNaN(tm[j])){tm[j]=0;}
            }
        }
        
        System.out.println("STABILITY ANALYSIS: ");
        System.out.println("tm1: " + tm[0] + "  tm2: " + tm[1]);
    }
    
    public boolean stabilityCheck(){
        boolean stable = false;
        System.out.println("starting stability analysis....");
        lowestGibbsEnergyPhase = findLowestGibbsEnergyPhase();
        if(system.getPhases()[lowestGibbsEnergyPhase].getNumberOfComponents()>1){
            try{
                stabilityAnalysis();
            }
            catch(Exception e){
            }
        }
         //System.out.println("tm0 " + tm[0]);
        // System.out.println("tm1 " + tm[1]);
        if(!(tm[0]<-1e-7) && !(tm[1]<-1e-7)){
            stable = true;
            system.init(0);
            // System.out.println("system is stable");
            // System.out.println("Stable phase is : " + lowestGibbsEnergyPhase);
            system.setNumberOfPhases(1);
            if (lowestGibbsEnergyPhase==0) system.setPhaseType(0, 1);
            else system.setPhaseType(0, 0);
            system.init(3);
            if(solidCheck){
                this.solidPhaseFlash();
            }
        }
        return stable;
    }
    
    public void displayResult(){
        system.display();
    }
    
    public void solidPhaseFlash(){
        boolean solidPhase = false;
        double frac=0;
        int solid=0;
        double[] tempVar = new double[system.getPhases()[0].getNumberOfComponents()];
        //system.setPhaseIndex(system.getNumberOfPhases(), 3);
        system.setNumberOfPhases(system.getNumberOfPhases()+1);
        System.out.println("numb " + system.getNumberOfPhases());
        system.init(1);
        
        for(int k=0;k<system.getPhase(0).getNumberOfComponents();k++){
            tempVar[k] = system.getPhase(0).getComponents()[k].getz();
            for(int i=0;i<system.getNumberOfPhases()-1;i++){
                tempVar[k] -= system.getBeta(i)*system.getPhase(3).getComponent(k).getFugasityCoeffisient()/system.getPhase(i).getComponent(k).getFugasityCoeffisient();
            }
            
            if(tempVar[k]>0.0 && tempVar[k]>frac){
                solidPhase=true;
                solid = k;
                frac = tempVar[k];
                for(int p=0;p<system.getPhases()[0].getNumberOfComponents();p++){
                    system.getPhases()[3].getComponents()[p].setx(1.0e-20);
                }
                system.getPhases()[3].getComponents()[solid].setx(1.0);
            }
            System.out.println("tempVar: " + tempVar[k]);
        }
        
        if(solidPhase){
            if(frac<system.getPhases()[0].getComponents()[solid].getz()+1e10){
                for(int i=0;i<system.getNumberOfPhases()-1;i++){
                    // system.getPhases()[i].getComponents()[solid].setx(1.0e-10);
                }
                system.init(1);
                System.out.println("solid phase will form..." + system.getNumberOfPhases());
                System.out.println("freezing component " + solid);
                system.setBeta(system.getNumberOfPhases()-1,frac);
                system.initBeta();
                system.setBeta(system.getNumberOfPhases()-1,system.getPhase(3).getComponent(solid).getNumberOfmoles()/system.getNumberOfMoles());
                //                double phasetot=0.0;
                //                for(int ph=0;ph<system.getNumberOfPhases();ph++){
                //                    phasetot += system.getPhase(ph).getBeta();
                //                }
                //                for(int ph=0;ph<system.getNumberOfPhases();ph++){
                //                    system.setBeta(ph, system.getPhase(ph).getBeta()/phasetot);
                //                }
                system.init(1);
                //                for(int ph=0;ph<system.getNumberOfPhases();ph++){
                //                    System.out.println("beta " + system.getPhase(ph).getBeta());
                //                }
//                TPmultiflash operation = new TPmultiflash(system, true);
//                operation.run();
                                SolidFlash solflash = new SolidFlash(system);
                                solflash.setSolidComponent(solid);
                                solflash.run();
            }
            else{
                System.out.println("all liquid will freeze out - removing liquid phase..");
                //int phasesNow = system.getNumberOfPhases()-1;
                //                system.init(0);
                //system.setNumberOfPhases(phasesNow);
                //system.setNumberOfPhases(system.getNumberOfPhases()-1);
                //system.setPhaseIndex(system.getNumberOfPhases()-1, 3);
                // system.setBeta(1-system.getPhases()[0].getComponents()[solid].getz());
                // system.init(1);
                // system.init_x_y();
                // system.init(1);
                //                solidPhaseFlash();
                // solid-vapor flash
            }
            
        }
        else{
            system.setNumberOfPhases(system.getNumberOfPhases()-1);
            System.out.println("no solid phase will form..");
        }
    }
    
    public void printToFile(String name) {
    }
    
    public void createNetCdfFile(String name) {
    }
    
    public double[][] getPoints(int i){
        return null;
    }
}
